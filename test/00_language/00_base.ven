distinct ven.tests.language.base;

ensure "Sanity of data types" {
  should "be of correct type"
    0.0 is num;
    12.345678 is num;
    1234567890 is num;
    1_234_567_890 is num;

    "foo bar baz" is str;
    "\n\t\r" is str;
    "\"qux\"" is str;

    [] is vec;
    [0] is vec;
    [[[]]] is vec;
    [0, "1", "2"] is vec;
    [0, "1", "2", [3]] is vec;
    [[0], [1], [2]] is vec

  should "support map"
    %{} is map;
    %{ "a" 1 } is map;
    [1, 2, 3] is not map;
    %{ "a" 1 }["a"] is 1;
    %{ "a" 1, "b" 2 }["a", "b"] is [1, 2];
    #%{} is 0;
    #%{"a" 2, "b" 3} is 2;
    %{"a" 2, "b" 3}.keys is ["a", "b"];
    %{"a" 2, "b" 3}.vals is [2, 3]
}

ensure "Valid principles of falsehood (/ truthiness)" {
  should "view certain values as falsey"
    0? is false;
    ""? is false;
    []? is false;
    (false)? is false;
    %{}? is false

  should "correctly invert falsey values"
    not 0 is true;
    not "" is true;
    not [] is true;
    not false is true;
    not %{} is true

  should "view all other values as truthy"
    12? is true;
    "foobar"? is true;
    (true)? is true;
    [1]? is true;
    [1, 2, 3]? is true;
    %{"a" 1, "b" 3}? is true

  should "correctly invert truthy values"
    not 12? is false;
    not "foobar"? is false;
    not (true)? is false;
    not [1]? is false;
    not [1, 2, 3]? is false;
    not %{"a" 1, "b" 3} is false
}

ensure "Sanity of unary operators" {
  should "return correct result when operand of expected type"
    +1 is 1;
    -1 is -1;
    ~"hello" is "hello";
    &[1] is [1];
    #[1, 2, 3] is 3;
    #"hello" is 5
    #  %{1 2 3 4} is %{1 2 3 4}

  should "return correct result when operand of unexpected type"
    +"1" is 1;
    +[2, 4, 6] is 3;
    +true is 1;
    +false is 0;

    -"1" is -1;
    -[2, 4, 6] is -3;
    -true is -1;
    -false is 0;

    ~123 is "123";
    ~[1, 2, 3] is "[1, 2, 3]";
    ~true is "true";
    ~false is "false";

    &1 is [1];
    &"1" is ["1"];
    &true is [true];
    &false is [false];

    #123 is 3;
    #true is 4;
    #false is 5;

    %123 dies;
    %"123" dies;
    %true dies;
    %false dies;
    %[1] dies;
    #  %[1 2] is %{1 2}
    %[1 2 3] dies
    #  %[1 2 3 4] is %{1 2 3 4}
}

ensure "Sanity of binary operators" {
  should "return correct result when operands of expected types"
    1 < 2;
    2 > 1;
    2 <= 2;
    5 >= 4;

    1 + 1 is 2;
    2 - 2 is 0;
    2 * 2 is 4;
    2 / 2 is 1;

    [1] & [2] is [1, 2];
    "lead" ~ "tail" is "leadtail";

    "a" x 10 is "aaaaaaaaaa";
    [1] x 10 is [1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    [1, 2, 3] x 3 is [1, 2, 3, 1, 2, 3, 1, 2, 3]

  should "return correct result when operands of unexpected types"
    [1] < "12";
    "123" > [1, 2];
    [1, 2] <= [1, 2, 3];
    "123" >= 3;
    "1" < "2" is false;
    "foo" > "barbaz" is false;
    "1" < "hello";
    "barbaz" > "foo";

    "1" + 1 is 2;
    2 - "2" is 0;
    "2" * ["two", "items"] is 4;
    "2" / true is 2;

    1 & 2 is [1, 2];
    [1] & 2 is [1, 2];
    1 & [2] is [1, 2];

    1 ~ 2 is "12";
    "1" ~ 2 is "12";
    1 ~ "2" is "12";

    10 x "a" is "aaaaaaaaaa";
    10 x [1] is [1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    0 x 10 is [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

  should "check for types/type inheritance correctly"
    1 is num;
    1 is not str;
    "hello" is str;
    [2, 4, 6] is vec;
    from 10 is range;
    to 10 is range;
    1 to 10 is range;
    typeof is builtin;
    typeof is function;
    num is type;
    str is type;
    vec is type;
    type is type;
    function is type;
    type is not function;
    builtin is function;
    concrete is function;
    lambda is function;
    function is not builtin;
    function is not lambda;
    compound is type;
    type is not compound;
    vec(num) is compound;
    vec(num) is vec(num);
    vec(num, 1, 2) is vec(num, 1, 2)

  should "assign correct types to everything in typeof()"
    typeof(1) is num;
    typeof("hello") is str;
    typeof([2, 4, 6]) is vec;
    typeof(from 10) is range;
    typeof(to 10) is range;
    typeof(1 to 10) is range;
    typeof(typeof) is builtin;
    typeof(typeof) is function; # builtin is function
    typeof(type) is type;
    typeof(num) is type;
    typeof(vec(num)) is type; # compound is type
    typeof(vec(num)) is compound;
    typeof(vec(num, type)) is compound
}
