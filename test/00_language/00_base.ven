distinct ven.tests.language.base;

ensure "Sanity of data types" {
  should "be of correct type"
    0.0 is num;
    12.345678 is num;
    1234567890 is num;
    1_234_567_890 is num;

    "foo bar baz" is str;
    "\n\t\r" is str;
    "\"qux\"" is str;

    [] is vec;
    [0] is vec;
    [[[]]] is vec;
    [0, "1", "2"] is vec;
    [0, "1", "2", [3],] is vec;
    [[0], [1], [2]] is vec
}

ensure "Valid principles of falsehood (/ truthiness)" {
  should "view certain values as falsey"
    0? is false;
    ""? is false;
    []? is false;
    (false)? is false

  should "correctly invert falsey values"
    not 0 is true;
    not "" is true;
    not [] is true;
    not false is true

  should "view all other values as truthy"
    12? is true;
    "foobar"? is true;
    (true)? is true;
    [1]? is true;
    [1, 2, 3]? is true

  should "correctly invert truthy values"
    not 12? is false;
    not "foobar"? is false;
    not (true)? is false;
    not [1]? is false;
    not [1, 2, 3]? is false
}

ensure "Sanity of unary operators" {
  should "return correct result when operand of expected type"
    +1 is 1;
    -1 is -1;
    ~"hello" is "hello";
    &[1] is [1];
    #[1, 2, 3] is 3;
    #"hello" is 5

  should "return correct result when operand of unexpected type"
    +"1" is 1;
    +[2, 4, 6] is 3;
    +true is 1;
    +false is 0;

    -"1" is -1;
    -[2, 4, 6] is -3;
    -true is -1;
    -false is 0;

    ~123 is "123";
    ~[1, 2, 3] is "[1, 2, 3]";
    ~true is "true";
    ~false is "false";

    &1 is [1];
    &"1" is ["1"];
    &true is [true];
    &false is [false];

    #123 is 3;
    #true is 4;
    #false is 5
}

ensure "Sanity of binary operators" {
  should "return correct result when operands of expected types"
    1 < 2;
    2 > 1;
    2 <= 2;
    5 >= 4;

    1 + 1 is 2;
    2 - 2 is 0;
    2 * 2 is 4;
    2 / 2 is 1;

    [1] & [2] is [1, 2];
    "lead" ~ "tail" is "leadtail";

    "a" x 10 is "aaaaaaaaaa";
    [1] x 10 is [1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    [1, 2, 3] x 3 is [1, 2, 3, 1, 2, 3, 1, 2, 3]

  should "return correct result when operands of unexpected types"
    [1] < "12";
    "123" > [1, 2];
    [1, 2] <= [1, 2, 3];
    "123" >= 3;

    "1" + 1 is 2;
    2 - "2" is 0;
    "2" * ["two", "items"] is 4;
    "2" / true is 2;

    1 & 2 is [1, 2];
    [1] & 2 is [1, 2];
    1 & [2] is [1, 2];

    1 ~ 2 is "12";
    "1" ~ 2 is "12";
    1 ~ "2" is "12";

    10 x "a" is "aaaaaaaaaa";
    10 x [1] is [1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    0 x 10 is [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
}
